<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>They Lied Meme Machine</title>
  <script src="https://unpkg.com/konva@9.3.6/konva.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Impact&family=Anton&family=Arial+Black&family=Inter&family=Arial&display=swap" rel="stylesheet">
  <style>
    body { margin: 0; font-family: Arial, sans-serif; background: #ccc; }
    .top-bar { background: #000; color: #fff; padding: 10px; display: flex; justify-content: space-between; align-items: center; }
    .top-bar select, .top-bar button { background: #333; color: #fff; border: none; padding: 5px 10px; margin-right: 5px; cursor: pointer; }
    .sidebar { background: #ddd; width: 200px; padding: 10px; float: left; height: calc(100vh - 80px); overflow-y: auto; }
    .sidebar h2 { font-weight: bold; margin: 10px 0 5px; }
    .sidebar button, .sidebar select, .sidebar input { width: 100%; padding: 5px; margin: 5px 0; border: 1px solid #999; }
    .canvas-container { margin-left: 220px; height: calc(100vh - 80px); background: #fff; position: relative; overflow: auto; }
    #canvas { position: absolute; }
    .bottom-bar { background: #bbb; padding: 10px; position: fixed; bottom: 0; width: 100%; display: flex; gap: 10px; }
    .bottom-bar select, .bottom-bar input { padding: 5px; border: 1px solid #999; }
    .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); }
    .modal-content { background: #fff; margin: 10% auto; padding: 20px; width: 80%; max-width: 500px; max-height: 80vh; overflow-y: auto; }
    .modal.active { display: block; }
    .modal button { background: #c00; color: #fff; border: none; padding: 5px 10px; float: right; }
    .text-layer { white-space: nowrap; overflow: hidden; }
    [disabled] { opacity: 0.5; pointer-events: none; }
  </style>
</head>
<body>
  <div class="top-bar">
    <div>
      <select id="template">
        <option>Blank</option>
        <option>Before / After</option>
        <option>Hoodie Reaction</option>
        <option>Lie of the Week</option>
        <option>Receipts Collage (2×2)</option>
        <option>Chart Dunk</option>
        <option>Villain Board (Top 6)</option>
        <option>Stamp Only</option>
      </select>
      <button id="undo" disabled><i class="fas fa-undo"></i> Undo</button>
      <button id="redo" disabled><i class="fas fa-redo"></i> Redo</button>
      <button id="help-toggle"><i class="fas fa-question"></i></button>
    </div>
    <span>THEY LIED MEME MACHINE — v1.2</span>
    <div>
      <button id="fit">Fit 50%</button>
      <button id="export">Export PNG</button>
    </div>
  </div>

  <div class="sidebar">
    <div>
      <h2>Add</h2>
      <button id="add-text">Text</button>
      <button id="add-logo">Logo</button>
      <button id="add-stamp">THEY LIED Stamp</button>
      <button id="lerp">Lerp (Smooth Move)</button>
    </div>
    <div>
      <h2>Arrange</h2>
      <button id="bring-forward">Bring Forward (+1)</button>
      <button id="send-backward">Send Backward (−1)</button>
      <button id="clear-all">Clear All</button>
    </div>
    <div>
      <h2>Canvas</h2>
      <select id="canvas-size">
        <option value="1600x900">Wide 1600×900</option>
        <option value="1920x1080">HD 1920×1080</option>
        <option value="2048x1152">YouTube 2048×1152</option>
        <option value="1080x1080">Square 1080×1080</option>
      </select>
      <button id="apply-size">Apply</button>
      <input id="bg-color" type="color" value="#ffffff">
    </div>
    <div>
      <h2>Draw (Paint)</h2>
      <label><input id="draw-toggle" type="checkbox"> Enable Draw</label>
      <div>
        <label>Size</label>
        <input id="brush-size" type="range" min="1" max="50" value="5">
      </div>
      <button id="clear-draw">Clear</button>
      <p>While Draw is enabled, strokes are not auto-selected.</p>
    </div>
  </div>

  <div class="canvas-container">
    <div id="canvas"></div>
  </div>

  <div class="bottom-bar">
    <select id="font">
      <option>Impact</option>
      <option>Anton</option>
      <option>Arial Black</option>
      <option>Inter</option>
      <option>Arial</option>
    </select>
    <input id="font-size" type="number" value="24" min="8" max="200">
    <label><input id="stamp-style" type="checkbox"> Stamp Style</label>
    <input id="text-input" type="text" placeholder="Edit text here">
  </div>

  <div id="help-modal" class="modal">
    <div class="modal-content">
      <h2>They Lied Meme Machine — Help & Shortcuts</h2>
      <button id="close-help">Close</button>
      <p>Quick guide to build memes fast. Works like Photoshop: proportional scaling by default, Shift to free-distort, Alt/Option to scale from center.</p>
      <ul>
        <li><b>Selection & moving</b>: Click to select, Shift-click to multi-select. Drag empty canvas to marquee-select. Arrow keys to nudge (Shift = 10px).</li>
        <li><b>Resize & rotate</b>: Drag blue corner dots to scale (proportional). Hold Shift = free distort. Hold Alt/Option = scale from center. Drag blue circle to rotate.</li>
        <li><b>Layers</b>: Bring Forward / Send Backward move one step. Repeat to reach top/bottom.</li>
        <li><b>Draw mode</b>: Enable Draw to paint. Strokes become movable layers after disabling Draw. Change brush size with slider.</li>
        <li><b>Text</b>: Double-click text to edit in bottom bar. “Stamp Style” adds red THEY LIED bar with white text.</li>
        <li><b>Export</b>: Click “Export PNG” for high-quality image.</li>
        <li><b>Shortcuts</b>: Ctrl+Z (Undo), Ctrl+Shift+Z (Redo), ? (Help), Esc (Cancel selection).</li>
      </ul>
    </div>
  </div>

  <script>
    const version = 'v1.2';
    const stage = new Konva.Stage({ container: 'canvas', width: 1600, height: 900 });
    const layer = new Konva.Layer();
    stage.add(layer);
    let undoStack = [], redoStack = [], isDrawing = false, lastLine = null, lerpEnabled = false;
    let selectedNode = null, transformer = new Konva.Transformer({ centeredScaling: true });

    // Save state for undo/redo
    function saveState() {
      undoStack.push(JSON.stringify(layer.toJSON()));
      redoStack = [];
      updateButtonStates();
      localStorage.setItem('memeCanvas', JSON.stringify(layer.toJSON()));
    }

    function updateButtonStates() {
      document.getElementById('undo').disabled = undoStack.length === 0;
      document.getElementById('redo').disabled = redoStack.length === 0;
    }

    // Templates
    document.getElementById('template').addEventListener('change', (e) => {
      layer.destroyChildren();
      const templates = {
        'Before / After': () => addText('Before', 100, 100).concat(addText('After', 200, 100)),
        'Stamp Only': () => [addStamp(100, 100)],
      };
      if (templates[e.target.value]) {
        templates[e.target.value]().forEach(node => layer.add(node));
        saveState();
      }
    });

    // Add text
    function addText(text, x, y) {
      const textNode = new Konva.Text({
        x, y, text, fontSize: 24, fontFamily: 'Impact', fill: 'black',
        draggable: true, name: 'text-layer'
      });
      textNode.on('dblclick', () => {
        const input = document.getElementById('text-input');
        input.value = textNode.text();
        input.focus();
        selectedNode = textNode;
      });
      textNode.on('click', selectNode);
      layer.add(textNode);
      return [textNode];
    }

    // Add stamp
    function addStamp(x, y) {
      const stamp = new Konva.Text({
        x, y, text: 'THEY LIED', fontSize: 48, fontFamily: 'Impact',
        fill: 'white', stroke: 'black', strokeWidth: 2,
        background: 'red', padding: 10, draggable: true, name: 'text-layer'
      });
      stamp.on('click', selectNode);
      layer.add(stamp);
      return stamp;
    }

    // Add logo
    function addLogo(x, y) {
      const logo = new Konva.Rect({ x, y, width: 100, height: 100, fill: 'gray', draggable: true });
      logo.on('click', selectNode);
      layer.add(logo);
      return logo;
    }

    // Selection
    function selectNode(e) {
      if (isDrawing) return;
      selectedNode = e.target;
      transformer.nodes([selectedNode]);
      layer.add(transformer);
      layer.draw();
    }

    // Canvas controls
    document.getElementById('canvas-size').addEventListener('change', (e) => {
      const [width, height] = e.target.value.split('x').map(Number);
      stage.size({ width, height });
      saveState();
    });

    document.getElementById('apply-size').addEventListener('click', () => {
      const [width, height] = document.getElementById('canvas-size').value.split('x').map(Number);
      stage.size({ width, height });
      saveState();
    });

    document.getElementById('bg-color').addEventListener('input', (e) => {
      stage.container().style.backgroundColor = e.target.value;
      saveState();
    });

    // Add elements
    document.getElementById('add-text').addEventListener('click', () => {
      addText('New Text', 100, 100);
      saveState();
    });

    document.getElementById('add-logo').addEventListener('click', () => {
      addLogo(100, 100);
      saveState();
    });

    document.getElementById('add-stamp').addEventListener('click', () => {
      addStamp(100, 100);
      saveState();
    });

    document.getElementById('lerp').addEventListener('click', () => {
      lerpEnabled = !lerpEnabled;
      this.textContent = `Lerp (${lerpEnabled ? 'On' : 'Off'})`;
    });

    // Text editing
    document.getElementById('text-input').addEventListener('input', (e) => {
      if (selectedNode && selectedNode.name() === 'text-layer') {
        selectedNode.text(e.target.value);
        layer.draw();
        saveState();
      }
    });

    document.getElementById('font').addEventListener('change', (e) => {
      if (selectedNode && selectedNode.name() === 'text-layer') {
        selectedNode.fontFamily(e.target.value);
        layer.draw();
        saveState();
      }
    });

    document.getElementById('font-size').addEventListener('input', (e) => {
      if (selectedNode && selectedNode.name() === 'text-layer') {
        selectedNode.fontSize(Number(e.target.value));
        layer.draw();
        saveState();
      }
    });

    document.getElementById('stamp-style').addEventListener('change', (e) => {
      if (selectedNode && selectedNode.name() === 'text-layer') {
        if (e.target.checked) {
          selectedNode.fill('white');
          selectedNode.stroke('black');
          selectedNode.strokeWidth(2);
          selectedNode.background('red');
          selectedNode.padding(10);
        } else {
          selectedNode.fill('black');
          selectedNode.stroke(null);
          selectedNode.background(null);
          selectedNode.padding(0);
        }
        layer.draw();
        saveState();
      }
    });

    // Drawing
    document.getElementById('draw-toggle').addEventListener('change', (e) => {
      isDrawing = e.target.checked;
      transformer.nodes([]);
      layer.draw();
    });

    stage.on('mousedown', (e) => {
      if (!isDrawing || e.target !== stage) return;
      lastLine = new Konva.Line({
        stroke: 'black',
        strokeWidth: document.getElementById('brush-size').value,
        points: [stage.getPointerPosition().x, stage.getPointerPosition().y],
        draggable: true
      });
      layer.add(lastLine);
    });

    stage.on('mousemove', () => {
      if (!isDrawing || !lastLine) return;
      const pos = stage.getPointerPosition();
      const newPoints = lastLine.points().concat([pos.x, pos.y]);
      lastLine.points(newPoints);
      layer.draw();
    });

    stage.on('mouseup', () => {
      if (lastLine) {
        lastLine.on('click', selectNode);
        saveState();
        lastLine = null;
      }
    });

    document.getElementById('brush-size').addEventListener('input', (e) => {
      if (lastLine) {
        lastLine.strokeWidth(Number(e.target.value));
        layer.draw();
      }
    });

    document.getElementById('clear-draw').addEventListener('click', () => {
      layer.find('Line').forEach(line => line.destroy());
      layer.draw();
      saveState();
    });

    // Arrange
    document.getElementById('bring-forward').addEventListener('click', () => {
      if (selectedNode) {
        selectedNode.moveUp();
        layer.draw();
        saveState();
      }
    });

    document.getElementById('send-backward').addEventListener('click', () => {
      if (selectedNode) {
        selectedNode.moveDown();
        layer.draw();
        saveState();
      }
    });

    document.getElementById('clear-all').addEventListener('click', () => {
      layer.destroyChildren();
      transformer.nodes([]);
      layer.draw();
      saveState();
    });

    // Undo/Redo
    document.getElementById('undo').addEventListener('click', () => {
      if (undoStack.length) {
        redoStack.push(JSON.stringify(layer.toJSON()));
        layer.destroyChildren();
        layer.fromJSON(undoStack.pop());
        layer.draw();
        updateButtonStates();
      }
    });

    document.getElementById('redo').addEventListener('click', () => {
      if (redoStack.length) {
        undoStack.push(JSON.stringify(layer.toJSON()));
        layer.destroyChildren();
        layer.fromJSON(redoStack.pop());
        layer.draw();
        updateButtonStates();
      }
    });

    // Export
    document.getElementById('export').addEventListener('click', () => {
      stage.toDataURL({
        callback: (dataUrl) => {
          const link = document.createElement('a');
          link.href = dataUrl;
          link.download = 'meme.png';
          link.click();
        }
      });
    });

    // Fit
    document.getElementById('fit').addEventListener('click', () => {
      const container = stage.container().parentElement;
      stage.scale({ x: 0.5, y: 0.5 });
      container.scrollLeft = (stage.width() * 0.5 - container.clientWidth) / 2;
      container.scrollTop = (stage.height() * 0.5 - container.clientHeight) / 2;
      layer.draw();
    });

    // Help modal
    document.getElementById('help-toggle').addEventListener('click', () => {
      document.getElementById('help-modal').classList.add('active');
    });

    document.getElementById('close-help').addEventListener('click', () => {
      document.getElementById('help-modal').classList.remove('active');
    });

    // Shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === '?') document.getElementById('help-toggle').click();
      if (e.key === 'Escape') {
        transformer.nodes([]);
        layer.draw();
      }
      if (e.ctrlKey && e.key === 'z') document.getElementById('undo').click();
      if (e.ctrlKey && e.shiftKey && e.key === 'Z') document.getElementById('redo').click();
      if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        if (selectedNode) {
          const shift = e.shiftKey ? 10 : 1;
          selectedNode.x(selectedNode.x() + (e.key === 'ArrowRight' ? shift : e.key === 'ArrowLeft' ? -shift : 0));
          selectedNode.y(selectedNode.y() + (e.key === 'ArrowDown' ? shift : e.key === 'ArrowUp' ? -shift : 0));
          layer.draw();
          saveState();
        }
      }
    });

    // Load auto-saved state
    const saved = localStorage.getItem('memeCanvas');
    if (saved) {
      layer.fromJSON(saved);
      layer.draw();
    }
  </script>
</body>
</html>